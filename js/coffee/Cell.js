// Generated by CoffeeScript 1.4.0
(function() {
  var Cell, DNA,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  DNA = require('./DNA');

  Cell = (function() {

    function Cell(row, col, parents) {
      this.state = 0;
      this.row = row;
      this.col = col;
      this.proteins = {};
      this.proteins[Cell.PROTEIN_CODE.alwaysOn] = {
        name: Cell.PROTEIN_CODE.alwaysOn,
        amount: 1
      };
      this.proteins[Cell.PROTEIN_CODE.newCell] = {
        name: Cell.PROTEIN_CODE.newCell,
        amount: 1
      };
      this.DNA = new DNA(parents);
      this.setWatchedValues();
    }

    Cell.PROTEIN_CODE = {
      alwaysOn: 'awysOn',
      newCell: 'newCel'
    };

    Cell.COMPUTE = {
      GoL: 0,
      proteins: 1
    };

    Cell.prototype.setWatchedValues = function() {
      var oneHundredPercent;
      oneHundredPercent = 4;
      this.p1 = this.proteins['newCel'].amount / oneHundredPercent;
      this.p2 = this.proteins['awysOn'].amount / oneHundredPercent;
      this.p3 = .5;
      return this.p4 = .7;
    };

    Cell.prototype.setState = function(newState) {
      return this.state = newState;
    };

    Cell.prototype.getState = function() {
      return this.state;
    };

    Cell.prototype.run = function(dish, computeType) {
      if (computeType == null) {
        computeType = Cell.COMPUTE.GoL;
      }
      switch (computeType) {
        case Cell.COMPUTE.GoL:
          return this.runGoL(dish);
        case Cell.COMPUTE.proteins:
          return this.runProteins(dish);
        default:
          throw Error('computeType not recognized');
      }
    };

    Cell.prototype.runProteins = function(dish) {
      var inProtein, outProtein, outputProteins, _i, _len;
      for (inProtein in this.proteins) {
        outputProteins = this.DNA.getProteinResponse(this.proteins[inProtein]);
        for (_i = 0, _len = outputProteins.length; _i < _len; _i++) {
          outProtein = outputProteins[_i];
          if (!this.DNA.connectionSilencedBy(this.proteins[inProtein], outProtein, this.proteins)) {
            console.log(this.proteins[inProtein], ' yields ', outProtein);
            if (__indexOf.call(this.proteins, outProtein) < 0) {
              this.proteins.push(outProtein);
            } else {
              this.proteins[outProtein.name].amount += outProtein.amount;
            }
          }
        }
      }
      setWatchedValues();
      return true;
    };

    Cell.prototype.runGoL = function(dish) {
      var neighbors;
      neighbors = dish.getNeighborCount(this.row, this.col);
      if (neighbors < 2) {
        return 0;
      } else if (neighbors > 3) {
        return 0;
      } else if (neighbors === 3) {
        return 1;
      } else {
        return dish.getCellState(this.row, this.col);
      }
    };

    Cell.prototype.step = function(dish) {
      return 0;
    };

    return Cell;

  })();

  module.exports = Cell;

}).call(this);
