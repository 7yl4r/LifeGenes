(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var Cell, DNA,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  DNA = require('./DNA');

  Cell = (function() {

    function Cell(row, col, parents) {
      this.state = 0;
      this.row = row;
      this.col = col;
      this.proteins = {};
      this.proteins[Cell.PROTEIN_CODE.alwaysOn] = {
        name: Cell.PROTEIN_CODE.alwaysOn,
        amount: 1
      };
      this.proteins[Cell.PROTEIN_CODE.newCell] = {
        name: Cell.PROTEIN_CODE.newCell,
        amount: 1
      };
      this.DNA = new DNA(parents);
      this.setWatchedValues();
    }

    Cell.PROTEIN_CODE = {
      alwaysOn: 'awysOn',
      newCell: 'newCel',
      cellDeath: 'deathh',
      cellEther: 'etherr'
    };

    Cell.prototype.setWatchedValues = function() {
      var oneHundredPercent;
      oneHundredPercent = 4;
      if (this.proteins[Cell.PROTEIN_CODE.alwaysOn] != null) {
        this.p1 = this.proteins[Cell.PROTEIN_CODE.alwaysOn].amount / oneHundredPercent;
      } else {
        this.p1 = 0;
      }
      if (this.proteins[Cell.PROTEIN_CODE.newCell] != null) {
        this.p2 = this.proteins[Cell.PROTEIN_CODE.newCell].amount / oneHundredPercent;
      } else {
        this.p2 = 0;
      }
      if (this.proteins[Cell.PROTEIN_CODE.cellDeath] != null) {
        this.p3 = this.proteins[Cell.PROTEIN_CODE.cellDeath].amount / oneHundredPercent;
      } else {
        this.p3 = 0;
      }
      if (this.proteins[Cell.PROTEIN_CODE.cellEther] != null) {
        this.p4 = this.proteins[Cell.PROTEIN_CODE.cellEther].amount / oneHundredPercent;
      } else {
        this.p4 = 0;
      }
    };

    Cell.prototype.setState = function(newState) {
      return this.state = newState;
    };

    Cell.prototype.getState = function() {
      return this.state;
    };

    Cell.prototype.respond = function() {
      this.setWatchedValues();
      if (this.birthCondition()) {
        this.makeAlive();
      }
      if (this.deathCondition()) {
        return this.die();
      }
    };

    Cell.prototype.birth = function(parents) {
      throw Error('notImpErr');
    };

    Cell.prototype.birthCondition = function() {
      return false;
    };

    Cell.prototype.deathCondition = function() {
      return false;
    };

    Cell.prototype.getProteinOutputs = function() {
      var inProtein, outProtein, outputProteins, theOutputs, _results;
      if (this.state > 0) {
        theOutputs = {};
        _results = [];
        for (inProtein in this.proteins) {
          outputProteins = this.DNA.getProteinResponse(this.proteins[inProtein]);
          _results.push((function() {
            var _i, _len, _results1;
            _results1 = [];
            for (_i = 0, _len = outputProteins.length; _i < _len; _i++) {
              outProtein = outputProteins[_i];
              if (!this.DNA.connectionSilencedBy(this.proteins[inProtein], outProtein, this.proteins)) {
                if (__indexOf.call(theOutput, outProtein) < 0) {
                  _results1.push(theOutputs[outProtein.name] = outProtein);
                } else {
                  _results1.push(theOutputs[outProtein.name].amount += outProtein.amount);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }
    };

    Cell.prototype.runGoL = function(dish) {
      var neighbors;
      neighbors = dish.getNeighborCount(this.row, this.col);
      if (neighbors < 2) {
        return 0;
      } else if (neighbors > 3) {
        return 0;
      } else if (neighbors === 3) {
        return 1;
      } else {
        return dish.getCellState(this.row, this.col);
      }
    };

    Cell.prototype.step = function(dish) {
      return 0;
    };

    return Cell;

  })();

  module.exports = Cell;

}).call(this);

},{"./DNA":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var ConnectionOperator, DNA, ProteinNode,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ConnectionOperator = (function() {

    function ConnectionOperator(fromCode, toCode, operatorBehavior) {
      var operators;
      operators = ['silencer'];
      if (__indexOf.call(operators, operatorBehavior) >= 0) {
        this.operator = operatorBehavior;
        this.from = fromCode;
        this.to = toCode;
      } else {
        throw Error('operatorBehavior not recognized');
      }
    }

    return ConnectionOperator;

  })();

  ProteinNode = (function() {

    function ProteinNode(proteinCode) {
      this.proteinCode = proteinCode;
      this.connections = [];
      this.silences = [];
    }

    return ProteinNode;

  })();

  DNA = (function() {

    function DNA(parents, doNotGenerate) {
      if (doNotGenerate == null) {
        doNotGenerate = false;
      }
      this._nodes = [];
      if (doNotGenerate) {
        return;
      } else if (parents != null) {
        console.log('inheriting...');
      } else {
        console.log('randomness');
      }
    }

    DNA.prototype.clone = function() {
      var newDNA, node, _i, _len, _ref;
      newDNA = new DNA([], true);
      _ref = dna.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        newDNA.nodes.push(node.clone());
      }
      return newDNA;
    };

    DNA.prototype.getProteinResponse = function(inputProtein) {
      return ['NotImp'];
    };

    DNA.prototype.connectionSilencedBy = function(inProtein, outProtein, proteinList) {
      return false;
    };

    return DNA;

  })();

  module.exports = DNA;

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var BoolArray, Cell, Dish, ProteinArray;

  Cell = require('./Cell');

  BoolArray = (function() {

    function BoolArray(rows, cols) {
      return (function() {
        var _i, _results;
        _results = [];
        for (_i = 1; 1 <= rows ? _i <= rows : _i >= rows; 1 <= rows ? _i++ : _i--) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (_j = 1; 1 <= cols ? _j <= cols : _j >= cols; 1 <= cols ? _j++ : _j--) {
              _results1.push(0);
            }
            return _results1;
          })());
        }
        return _results;
      })();
    }

    return BoolArray;

  })();

  ProteinArray = (function() {

    function ProteinArray(rows, cols) {
      this.arry = (function() {
        var _i, _results;
        _results = [];
        for (_i = 1; 1 <= rows ? _i <= rows : _i >= rows; 1 <= rows ? _i++ : _i--) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (_j = 1; 1 <= cols ? _j <= cols : _j >= cols; 1 <= cols ? _j++ : _j--) {
              _results1.push({});
            }
            return _results1;
          })());
        }
        return _results;
      })();
    }

    ProteinArray.prototype.addProtein = function(row, col, name, amount) {
      try {
        return this.arry[row][col][name].amount += amount;
      } catch (err) {
        return this.arry[row][col][name] = {
          name: name,
          amount: amount
        };
      }
    };

    ProteinArray.prototype.addProteinsAt = function(row, col, proteinList) {
      var prot, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = proteinList.length; _i < _len; _i++) {
        prot = proteinList[_i];
        _results.push(addProtein(row, col, prot.name, prot.amount));
      }
      return _results;
    };

    ProteinArray.prototype.getProteinsAt = function(row, col) {
      return this.arry[row][col];
    };

    return ProteinArray;

  })();

  Dish = (function() {

    function Dish(rows, cols, displayDiv, computeType) {
      var cellRow, col, row, _i, _j, _ref, _ref1;
      if (displayDiv == null) {
        displayDiv = '';
      }
      if (computeType == null) {
        computeType = Dish.COMPUTE.GoL;
      }
      this.generation = 0;
      this.rowCount = rows;
      this.colCount = cols;
      this.cellCount = rows * cols;
      this.renderDivSelector = displayDiv;
      this.computeType = computeType;
      this.cells = [];
      for (row = _i = 0, _ref = this.rowCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
        cellRow = [];
        for (col = _j = 0, _ref1 = this.colCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          cellRow.push(new Cell(row, col));
        }
        this.cells.push(cellRow);
      }
      this.TIMER_DELAY = 10;
      this.NEIGHBORHOOD_SIZE = 1;
    }

    Dish.COMPUTE = {
      GoL: 0,
      cumulativeProteins: 1
    };

    Dish.prototype.start = function() {
      var run,
        _this = this;
      this.running = true;
      run = function() {
        if (_this.running) {
          _this.step();
          setTimeout(run, _this.TIMER_DELAY);
          return true;
        } else {
          return false;
        }
      };
      return run();
    };

    Dish.prototype.stop = function() {
      return this.running = false;
    };

    Dish.prototype.step = function() {
      var colN, new_states, proteinOuts, rowN;
      console.log('generation ', this.generation, '->', this.generation + 1);
      switch (this.computeType) {
        case Dish.COMPUTE.GoL:
          new_states = new BoolArray(this.rowCount, this.colCount);
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              new_states[rowN][colN] = this.getCell(rowN, colN).runGoL(this);
            }
          }
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              this.setCellState(rowN, colN, new_states[rowN][colN]);
            }
          }
          break;
        case Dish.COMPUTE.cumulativeProteins:
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              this.getCell(rowN, colN).respond(this);
            }
          }
          proteinOuts = new ProteinArray(this.rowCount, this.colCount);
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              proteinOuts.addProteinsAt(rowN, colN, this.getCell(rowN, colN).getProteinOutputs());
            }
          }
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              this.spreadProteins(proteinOuts[rowN][colN]);
            }
          }
          break;
        default:
          throw Error('computeType not recognized');
      }
      this.generation += 1;
      this.render();
      return this.generation;
    };

    Dish.prototype.spreadProteins = function(proteinList) {
      throw Error('NotYetImpl');
    };

    Dish.prototype.getCellState = function(row, col) {
      return this.getCell(row, col).getState();
    };

    Dish.prototype.getCell = function(row, col) {
      var maxCol, maxRow;
      maxRow = this.rowCount;
      maxCol = this.colCount;
      row %= maxRow;
      col %= maxCol;
      if (col < 0) {
        col = maxCol + col;
      }
      if (row < 0) {
        row = maxRow + row;
      }
      if (col > maxCol) {
        col -= maxCol;
      }
      if (row > maxRow) {
        row -= maxRow;
      }
      return this.cells[row][col];
    };

    Dish.prototype.getNeighborCount = function(R, C) {
      var i, j, neighbors;
      R = parseInt(R);
      C = parseInt(C);
      neighbors = 0;
      i = -this.NEIGHBORHOOD_SIZE;
      while (i <= this.NEIGHBORHOOD_SIZE) {
        j = -this.NEIGHBORHOOD_SIZE;
        while (j <= this.NEIGHBORHOOD_SIZE) {
          if (i === 0 && j === 0) {
            j += 1;
          } else {
            neighbors += this.getCellState(R + i, C + j);
            j += 1;
          }
        }
        i += 1;
      }
      return neighbors;
    };

    Dish.prototype.setCellState = function(row, col, newState) {
      return this.getCell(row, col).setState(newState);
    };

    Dish.prototype.render = function(renderDivSelector) {
      if (renderDivSelector == null) {
        renderDivSelector = this.renderDivSelector;
      }
      if (renderDivSelector != null) {
        return dust.render('cellDish', {
          cells: main_dish.cells
        }, function(err, out) {
          var row, _i, _len, _ref;
          delete main_dish.cells.$len;
          delete main_dish.cells.$idx;
          _ref = main_dish.cells;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            row = _ref[_i];
            delete row.$len;
            delete row.$idx;
          }
          $(renderDivSelector).html(out);
          if (err) {
            return console.log(err);
          }
        });
      } else {
        return console.log('dish unrendered: no render div set');
      }
    };

    return Dish;

  })();

  module.exports = Dish;

}).call(this);

},{"./Cell":1}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var Cell, GUI,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Cell = require('./Cell');

  GUI = (function() {

    function GUI(dish, type) {
      if (type == null) {
        type = GUI.TYPE.master;
      }
      this.type = type;
      this.dish = dish;
      this.proteinsShowing = true;
      $(document).on("set-environment-type", function(event, newEnvType) {
        console.log("switching environment type to ", newEnvType);
        switch (newEnvType) {
          case ENVIRONMENT_TYPE["enum"][0]:
            return main_dish.computeType = Dish.COMPUTE.GoL;
          case ENVIRONMENT_TYPE["enum"][1]:
            return main_dish.computeType = Dish.COMPUTE.cumulativeProteins;
        }
      });
    }

    GUI.TYPE = {
      master: "master"
    };

    GUI.prototype.setInterfaceType = function(type) {
      switch (type) {
        case this.type:
          break;
        case __indexOf.call(GUI.TYPE, type) >= 0:
          return console.log("switching interface type to ", type);
        default:
          throw Error("unkown interface type requested");
      }
    };

    GUI.prototype.cellClick = function(cellEl) {
      this.toggleCell(cellEl);
    };

    GUI.prototype.toggleCell = function(cellEl) {
      if (cellEl.getAttribute('data-state') === '1') {
        cellEl.setAttribute('data-state', 0);
        this.dish.setCellState(cellEl.getAttribute('data-cell-row'), cellEl.getAttribute('data-cell-col'), 0);
      } else {
        cellEl.setAttribute('data-state', 1);
        this.dish.setCellState(cellEl.getAttribute('data-cell-row'), cellEl.getAttribute('data-cell-col'), 1);
      }
    };

    GUI.prototype.proteinDisplayToggle = function() {
      switch (this.proteinsShowing) {
        case true:
          $('.protein').hide();
          return this.proteinsShowing = false;
        case false:
          $('.protein').show();
          return this.proteinsShowing = true;
        default:
          throw Error('@proteinsShowing flag is non-boolean');
      }
    };

    return GUI;

  })();

  module.exports = GUI;

}).call(this);

},{"./Cell":1}],5:[function(require,module,exports){
DNA = require("./coffee/DNA.js")
Cell = require("./coffee/Cell.js")
Dish = require("./coffee/Dish.js")
GUI = require("./coffee/GUI.js")

// global constants
window.NUMBER_OF_ROWS = 15;
window.NUMBER_OF_COLS = 40;
window.NUMBER_OF_CELLS = NUMBER_OF_ROWS*NUMBER_OF_COLS;

// settings objects
window.ENVIRONMENT_TYPE = Object.freeze({enum:["Game_of_Life", "Protein_Life"]});

// global variables:
window.main_dish = new Dish(NUMBER_OF_ROWS, NUMBER_OF_COLS, '#cell-display-div');
window.gui = new GUI(main_dish);

$(document).ready(function(){
    // connect jquery event listeners to (mutable) GUI methods
    $(document).on('click', '.cell', function(evt) {
        return gui.cellClick(this);  // TODO: UI.cellClick
    });

    // TODO: rework this, multiple environment types (and UIs) not needed, perhaps should be "preset" or "demo" selector
    //$(document).on("set-environment-type", function(evt, selection){
    //    GUI.setEnvironmentType(selection)
    //});
});
},{"./coffee/Cell.js":1,"./coffee/DNA.js":2,"./coffee/Dish.js":3,"./coffee/GUI.js":4}]},{},[5]);
