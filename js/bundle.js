(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var COMPUTE, Cell, DNA, PROTEINS,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  DNA = require('./DNA');

  PROTEINS = {
    alwaysOn: 'awysOn',
    newCell: 'newCel'
  };

  COMPUTE = {
    GoL: 0,
    proteins: 1
  };

  Cell = (function() {

    function Cell(row, col, parent1, parent2) {
      this.state = 0;
      this.row = row;
      this.col = col;
      this.proteins = [PROTEINS.alwaysOn, PROTEINS.newCell];
      this.DNA = new DNA(parent1, parent2);
    }

    Cell.prototype.setState = function(newState) {
      return this.state = newState;
    };

    Cell.prototype.getState = function() {
      return this.state;
    };

    Cell.prototype.run = function(dish, computeType) {
      if (computeType == null) {
        computeType = COMPUTE.GoL;
      }
      switch (computeType) {
        case COMPUTE.GoL:
          return this.runGoL(dish);
        case COMPUTE.proteins:
          return this.runProteins(dish);
        default:
          throw Error('computeType not recognized');
      }
    };

    Cell.prototype.runProteins = function(dish) {
      var inProtein, outProtein, outputProteins, _i, _j, _len, _len1, _ref;
      _ref = this.proteins;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        inProtein = _ref[_i];
        outputProteins = this.DNA.getProteinResponse(inProtein);
        for (_j = 0, _len1 = outputProteins.length; _j < _len1; _j++) {
          outProtein = outputProteins[_j];
          if (!this.DNA.connectionSilencedBy(inProtein, outProtein, this.proteins)) {
            console.log(inProtein, ' yields ', outProtein);
            if (__indexOf.call(this.proteins, outProtein) < 0) {
              this.proteins.push(outProtein);
            } else {
              console.log('protein already here');
            }
          }
        }
      }
      return true;
    };

    Cell.prototype.runGoL = function(dish) {
      var neighbors;
      neighbors = dish.getNeighborCount(this.row, this.col);
      if (neighbors < 2) {
        return 0;
      } else if (neighbors > 3) {
        return 0;
      } else if (neighbors === 3) {
        return 1;
      } else {
        return dish.getCellState(this.row, this.col);
      }
    };

    Cell.prototype.step = function(dish) {
      return 0;
    };

    return Cell;

  })();

  module.exports = Cell;

}).call(this);

},{"./DNA":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var ConnectionOperator, DNA, ProteinNode,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ConnectionOperator = (function() {

    function ConnectionOperator(fromCode, toCode, operatorBehavior) {
      var operators;
      operators = ['silencer'];
      if (__indexOf.call(operators, operatorBehavior) >= 0) {
        this.operator = operatorBehavior;
        this.from = fromCode;
        this.to = toCode;
      } else {
        throw Error('operatorBehavior not recognized');
      }
    }

    return ConnectionOperator;

  })();

  ProteinNode = (function() {

    function ProteinNode(proteinCode) {
      this.proteinCode = proteinCode;
      this.connections = [];
      this.silences = [];
    }

    return ProteinNode;

  })();

  DNA = (function() {

    function DNA(parent1, parent2) {
      this._nodes = [];
      if ((parent1 != null) && (parent2 != null)) {
        console.log('inheriting...');
      } else {
        console.log('randomness');
      }
    }

    DNA.prototype.getProteinResponse = function(inputProtein) {
      return ['NotImp'];
    };

    DNA.prototype.connectionSilencedBy = function(inProtein, outProtein, proteinList) {
      return false;
    };

    return DNA;

  })();

  module.exports = DNA;

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var BoolArray, Cell, Dish;

  Cell = require('./Cell');

  BoolArray = (function() {

    function BoolArray(rows, cols) {
      return (function() {
        var _i, _results;
        _results = [];
        for (_i = 1; 1 <= rows ? _i <= rows : _i >= rows; 1 <= rows ? _i++ : _i--) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (_j = 1; 1 <= cols ? _j <= cols : _j >= cols; 1 <= cols ? _j++ : _j--) {
              _results1.push(0);
            }
            return _results1;
          })());
        }
        return _results;
      })();
    }

    return BoolArray;

  })();

  Dish = (function() {

    function Dish(rows, cols, displayDiv) {
      var cellRow, col, row, _i, _j, _ref, _ref1;
      if (displayDiv == null) {
        displayDiv = '';
      }
      this.generation = 0;
      this.rowCount = rows;
      this.colCount = cols;
      this.cellCount = rows * cols;
      this.renderDivSelector = displayDiv;
      this.cells = [];
      for (row = _i = 0, _ref = this.rowCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
        cellRow = [];
        for (col = _j = 0, _ref1 = this.colCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          cellRow.push(new Cell(row, col));
        }
        this.cells.push(cellRow);
      }
      this._cell_states = new BoolArray(this.rowCount, this.colCount);
      if (typeof document !== "undefined" && document !== null) {
        $(document).on("set-environment-type", function(evt, selection) {
          switch (selection) {
            case "Game_of_Life":
              return $(document).on('click', '.cell', function(evt) {
                return main_dish.cellClick(this);
              });
            default:
              console.log('unknown env type:', selection);
              throw Error('unknown env type');
          }
        });
      }
      this.TIMER_DELAY = 10;
      this.NEIGHBORHOOD_SIZE = 1;
    }

    Dish.prototype.start = function() {
      var run,
        _this = this;
      this.running = true;
      run = function() {
        if (_this.running) {
          _this.step();
          setTimeout(run, _this.TIMER_DELAY);
          return true;
        } else {
          return false;
        }
      };
      return run();
    };

    Dish.prototype.stop = function() {
      return this.running = false;
    };

    Dish.prototype.step = function() {
      var colN, new_states, rowN;
      console.log('generation ', this.generation, '->', this.generation + 1);
      new_states = new BoolArray(this.rowCount, this.colCount);
      for (rowN in this.cells) {
        for (colN in this.cells[rowN]) {
          new_states[rowN][colN] = this.getCell(rowN, colN).run(this);
        }
      }
      this._cell_states = new_states;
      for (rowN in this.cells) {
        for (colN in this.cells[rowN]) {
          this.setCellState(rowN, colN, new_states[rowN][colN]);
        }
      }
      this.generation += 1;
      this.render();
      return this.generation;
    };

    Dish.prototype.getCellState = function(row, col) {
      return this.getCell(row, col).getState();
    };

    Dish.prototype.getCell = function(row, col) {
      var maxCol, maxRow;
      maxRow = this.rowCount;
      maxCol = this.colCount;
      row %= maxRow;
      col %= maxCol;
      if (col < 0) {
        col = maxCol + col;
      }
      if (row < 0) {
        row = maxRow + row;
      }
      if (col > maxCol) {
        col -= maxCol;
      }
      if (row > maxRow) {
        row -= maxRow;
      }
      return this.cells[row][col];
    };

    Dish.prototype.getNeighborCount = function(R, C) {
      var i, j, neighbors;
      R = parseInt(R);
      C = parseInt(C);
      neighbors = 0;
      i = -this.NEIGHBORHOOD_SIZE;
      while (i <= this.NEIGHBORHOOD_SIZE) {
        j = -this.NEIGHBORHOOD_SIZE;
        while (j <= this.NEIGHBORHOOD_SIZE) {
          if (i === 0 && j === 0) {
            j += 1;
          } else {
            neighbors += this.getCellState(R + i, C + j);
            j += 1;
          }
        }
        i += 1;
      }
      return neighbors;
    };

    Dish.prototype.cellClick = function(cellEl) {
      this.toggleCell(cellEl);
    };

    Dish.prototype.toggleCell = function(cellEl) {
      if (cellEl.getAttribute('data-state') === '1') {
        cellEl.setAttribute('data-state', 0);
        this.setCellState(cellEl.getAttribute('data-cell-row'), cellEl.getAttribute('data-cell-col'), 0);
      } else {
        cellEl.setAttribute('data-state', 1);
        this.setCellState(cellEl.getAttribute('data-cell-row'), cellEl.getAttribute('data-cell-col'), 1);
      }
    };

    Dish.prototype.setCellState = function(row, col, newState) {
      return this.getCell(row, col).setState(newState);
    };

    Dish.prototype.render = function(renderDivSelector) {
      if (renderDivSelector == null) {
        renderDivSelector = this.renderDivSelector;
      }
      if (renderDivSelector != null) {
        return dust.render('cellDish', {
          cell_states: main_dish._cell_states
        }, function(err, out) {
          $(renderDivSelector).html(out);
          if (err) {
            return console.log(err);
          }
        });
      } else {
        return console.log('dish unrendered: no render div set');
      }
    };

    return Dish;

  })();

  module.exports = Dish;

}).call(this);

},{"./Cell":1}],4:[function(require,module,exports){
DNA = require("./coffee/DNA.js")
Cell = require("./coffee/Cell.js")
Dish = require("./coffee/Dish.js")

// global constants
window.NUMBER_OF_ROWS = 15;
window.NUMBER_OF_COLS = 40;
window.NUMBER_OF_CELLS = NUMBER_OF_ROWS*NUMBER_OF_COLS;

// settings objects
window.ENVIRONMENT_TYPE = Object.freeze({enum:["Game_of_Life", "Colorful_Life", "Moving_Life"]});

// global variables:
window.main_dish = new Dish(NUMBER_OF_ROWS, NUMBER_OF_COLS, '#cell-display-div');
},{"./coffee/Cell.js":1,"./coffee/DNA.js":2,"./coffee/Dish.js":3}]},{},[4]);
