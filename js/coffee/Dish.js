// Generated by CoffeeScript 1.4.0
(function() {
  var BoolArray, Cell, Dish, ProteinArray;

  Cell = require('./Cell');

  BoolArray = (function() {

    function BoolArray(rows, cols) {
      return (function() {
        var _i, _results;
        _results = [];
        for (_i = 1; 1 <= rows ? _i <= rows : _i >= rows; 1 <= rows ? _i++ : _i--) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (_j = 1; 1 <= cols ? _j <= cols : _j >= cols; 1 <= cols ? _j++ : _j--) {
              _results1.push(0);
            }
            return _results1;
          })());
        }
        return _results;
      })();
    }

    return BoolArray;

  })();

  ProteinArray = (function() {

    function ProteinArray(rows, cols) {
      this.arry = (function() {
        var _i, _results;
        _results = [];
        for (_i = 1; 1 <= rows ? _i <= rows : _i >= rows; 1 <= rows ? _i++ : _i--) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (_j = 1; 1 <= cols ? _j <= cols : _j >= cols; 1 <= cols ? _j++ : _j--) {
              _results1.push({});
            }
            return _results1;
          })());
        }
        return _results;
      })();
    }

    ProteinArray.prototype.addProtein = function(row, col, name, amount) {
      try {
        return this.arry[row][col][name].amount += amount;
      } catch (err) {
        return this.arry[row][col][name] = {
          name: name,
          amount: amount
        };
      }
    };

    ProteinArray.prototype.addProteinsAt = function(row, col, proteinList) {
      var prot, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = proteinList.length; _i < _len; _i++) {
        prot = proteinList[_i];
        _results.push(addProtein(row, col, prot.name, prot.amount));
      }
      return _results;
    };

    ProteinArray.prototype.getProteinsAt = function(row, col) {
      return this.arry[row][col];
    };

    return ProteinArray;

  })();

  Dish = (function() {

    function Dish(rows, cols, displayDiv, computeType) {
      var cellRow, col, row, _i, _j, _ref, _ref1;
      if (displayDiv == null) {
        displayDiv = '';
      }
      if (computeType == null) {
        computeType = Dish.COMPUTE.GoL;
      }
      this.generation = 0;
      this.rowCount = rows;
      this.colCount = cols;
      this.cellCount = rows * cols;
      this.renderDivSelector = displayDiv;
      this.computeType = computeType;
      this.cells = [];
      for (row = _i = 0, _ref = this.rowCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
        cellRow = [];
        for (col = _j = 0, _ref1 = this.colCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          cellRow.push(new Cell(row, col));
        }
        this.cells.push(cellRow);
      }
      this.TIMER_DELAY = 10;
      this.NEIGHBORHOOD_SIZE = 1;
    }

    Dish.COMPUTE = {
      GoL: 0,
      cumulativeProteins: 1
    };

    Dish.prototype.start = function() {
      var run,
        _this = this;
      this.running = true;
      run = function() {
        if (_this.running) {
          _this.step();
          setTimeout(run, _this.TIMER_DELAY);
          return true;
        } else {
          return false;
        }
      };
      return run();
    };

    Dish.prototype.stop = function() {
      return this.running = false;
    };

    Dish.prototype.step = function() {
      var colN, new_states, proteinOuts, rowN;
      console.log('generation ', this.generation, '->', this.generation + 1);
      switch (this.computeType) {
        case Dish.COMPUTE.GoL:
          new_states = new BoolArray(this.rowCount, this.colCount);
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              new_states[rowN][colN] = this.getCell(rowN, colN).runGoL(this);
            }
          }
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              this.setCellState(rowN, colN, new_states[rowN][colN]);
            }
          }
          break;
        case Dish.COMPUTE.cumulativeProteins:
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              this.getCell(rowN, colN).respond(this);
            }
          }
          proteinOuts = new ProteinArray(this.rowCount, this.colCount);
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              proteinOuts.addProteinsAt(rowN, colN, this.getCell(rowN, colN).getProteinOutputs());
            }
          }
          for (rowN in this.cells) {
            for (colN in this.cells[rowN]) {
              this.spreadProteins(proteinOuts.getProteinsAt(rowN, colN));
            }
          }
          break;
        default:
          throw Error('computeType not recognized');
      }
      this.generation += 1;
      this.render();
      return this.generation;
    };

    Dish.prototype.spreadProteins = function(proteinList, row, col) {
      var i, j, prot, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = proteinList.length; _i < _len; _i++) {
        prot = proteinList[_i];
        i = -(prot.amount - 1);
        _results.push((function() {
          var _results1;
          _results1 = [];
          while (i <= this.NEIGHBORHOOD_SIZE) {
            j = -(prot.amount(-1));
            while (j <= this.NEIGHBORHOOD_SIZE) {
              this.getCell(R + i, C + j).addProtein(prot.name, 1);
              j += 1;
            }
            _results1.push(i += 1);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Dish.prototype.getCellState = function(row, col) {
      return this.getCell(row, col).getState();
    };

    Dish.prototype.getCell = function(row, col) {
      var maxCol, maxRow;
      maxRow = this.rowCount;
      maxCol = this.colCount;
      row %= maxRow;
      col %= maxCol;
      if (col < 0) {
        col = maxCol + col;
      }
      if (row < 0) {
        row = maxRow + row;
      }
      if (col > maxCol) {
        col -= maxCol;
      }
      if (row > maxRow) {
        row -= maxRow;
      }
      return this.cells[row][col];
    };

    Dish.prototype.getNeighborCount = function(R, C) {
      var i, j, neighbors;
      R = parseInt(R);
      C = parseInt(C);
      neighbors = 0;
      i = -this.NEIGHBORHOOD_SIZE;
      while (i <= this.NEIGHBORHOOD_SIZE) {
        j = -this.NEIGHBORHOOD_SIZE;
        while (j <= this.NEIGHBORHOOD_SIZE) {
          if (i === 0 && j === 0) {
            j += 1;
          } else {
            neighbors += this.getCellState(R + i, C + j);
            j += 1;
          }
        }
        i += 1;
      }
      return neighbors;
    };

    Dish.prototype.setCellState = function(row, col, newState) {
      return this.getCell(row, col).setState(newState);
    };

    Dish.prototype.render = function(renderDivSelector) {
      if (renderDivSelector == null) {
        renderDivSelector = this.renderDivSelector;
      }
      if (renderDivSelector != null) {
        return dust.render('cellDish', {
          cells: main_dish.cells
        }, function(err, out) {
          var row, _i, _len, _ref;
          delete main_dish.cells.$len;
          delete main_dish.cells.$idx;
          _ref = main_dish.cells;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            row = _ref[_i];
            delete row.$len;
            delete row.$idx;
          }
          $(renderDivSelector).html(out);
          if (err) {
            return console.log(err);
          }
        });
      } else {
        return console.log('dish unrendered: no render div set');
      }
    };

    return Dish;

  })();

  module.exports = Dish;

}).call(this);
